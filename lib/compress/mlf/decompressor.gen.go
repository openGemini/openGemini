// Code generated by tmpl; DO NOT EDIT.
// https://github.com/benbjohnson/tmpl
//
// Source: decompressor.gen.go.tmpl

// Copyright 2025 Huawei Cloud Computing Technologies Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package mlf

import (
	"encoding/binary"
	"math"
)

type decodeFunc func(dst []float64, data []byte, precision, multiplicand float64, publicPrefixSize int)

var decodeFuncTable [maxFactorBits]decodeFunc

func init() {
	decodeFuncTable[1] = decodeItemSize1
	decodeFuncTable[2] = decodeItemSize2
	decodeFuncTable[4] = decodeItemSize4
	decodeFuncTable[8] = decodeItemSize8
	decodeFuncTable[16] = decodeItemSize16
	decodeFuncTable[32] = decodeItemSize32
	decodeFuncTable[3] = decodeItemSize3
	decodeFuncTable[5] = decodeItemSize5
	decodeFuncTable[6] = decodeItemSize6
	decodeFuncTable[7] = decodeItemSize7
	decodeFuncTable[9] = decodeItemSize9
	decodeFuncTable[10] = decodeItemSize10
	decodeFuncTable[11] = decodeItemSize11
	decodeFuncTable[12] = decodeItemSize12
	decodeFuncTable[13] = decodeItemSize13
	decodeFuncTable[14] = decodeItemSize14
	decodeFuncTable[15] = decodeItemSize15
	decodeFuncTable[17] = decodeItemSize17
	decodeFuncTable[18] = decodeItemSize18
	decodeFuncTable[19] = decodeItemSize19
	decodeFuncTable[20] = decodeItemSize20
	decodeFuncTable[21] = decodeItemSize21
	decodeFuncTable[22] = decodeItemSize22
	decodeFuncTable[23] = decodeItemSize23
	decodeFuncTable[24] = decodeItemSize24
	decodeFuncTable[25] = decodeItemSize25
	decodeFuncTable[26] = decodeItemSize26
	decodeFuncTable[27] = decodeItemSize27
	decodeFuncTable[28] = decodeItemSize28
	decodeFuncTable[29] = decodeItemSize29
	decodeFuncTable[30] = decodeItemSize30
	decodeFuncTable[31] = decodeItemSize31
	decodeFuncTable[33] = decodeItemSize33
	decodeFuncTable[34] = decodeItemSize34
	decodeFuncTable[35] = decodeItemSize35
	decodeFuncTable[36] = decodeItemSize36
	decodeFuncTable[37] = decodeItemSize37
	decodeFuncTable[38] = decodeItemSize38
	decodeFuncTable[39] = decodeItemSize39
	decodeFuncTable[40] = decodeItemSize40
	decodeFuncTable[41] = decodeItemSize41
	decodeFuncTable[42] = decodeItemSize42
	decodeFuncTable[43] = decodeItemSize43
	decodeFuncTable[44] = decodeItemSize44
	decodeFuncTable[45] = decodeItemSize45
	decodeFuncTable[46] = decodeItemSize46
	decodeFuncTable[47] = decodeItemSize47
	decodeFuncTable[48] = decodeItemSize48
	decodeFuncTable[49] = decodeItemSize49
}

func decodeItemSize1(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 1
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize2(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 2
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize4(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 4
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize8(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 8
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize16(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 16
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize32(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 32
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f := math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	size := len(dst)
	n := size - size%(64/itemSize)
	var swap uint64
	i := 0

	for i < n {
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		i++
		dst[i] = decode(swap >> (64 - itemSize))
		i++
	}

	if n == size {
		return
	}

	swap = binary.BigEndian.Uint64(data)
	for j := i; j < size; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize3(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 3
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize5(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 5
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize6(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 6
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize7(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 7
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize9(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 9
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize10(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 10
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize11(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 11
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize12(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 12
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize13(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 13
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize14(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 14
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize15(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 15
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize17(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 17
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize18(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 18
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize19(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 19
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize20(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 20
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize21(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 21
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize22(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 22
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize23(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 23
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize24(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 24
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize25(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 25
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize26(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 26
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize27(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 27
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize28(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 28
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize29(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 29
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize30(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 30
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize31(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 31
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if (n - i) < 64/itemSize {
			break
		}

		dst[i] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
		swapSize -= itemSize
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}

	for j := i; j < n; j++ {
		dst[j] = decode(swap >> (64 - itemSize))
		swap <<= itemSize
	}
}

func decodeItemSize33(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 33
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize34(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 34
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize35(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 35
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize36(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 36
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize37(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 37
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize38(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 38
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize39(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 39
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize40(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 40
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize41(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 41
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize42(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 42
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize43(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 43
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize44(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 44
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize45(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 45
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize46(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 46
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize47(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 47
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize48(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 48
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}

func decodeItemSize49(dst []float64, data []byte, precision float64, multiplicand float64, publicPrefixSize int) {
	const itemSize = 49
	var f float64
	var base uint64 = ((1<<publicPrefixSize - 1) << (mantissaBits - publicPrefixSize)) | (middleNumber << mantissaBits)
	left := mantissaBits - itemSize - publicPrefixSize

	var decode = func(c uint64) float64 {
		f = math.Float64frombits(base|(c<<left)) - 1
		return math.Floor(multiplicand*f*precision) / precision
	}

	i := 0
	n := len(dst)
	var swap, coefficient uint64
	var swapSize = 0

	for i < n {
		coefficient = swap >> (64 - itemSize)
		swap = binary.BigEndian.Uint64(data)
		data = data[8:]

		k := itemSize - swapSize
		swapSize = 64 - k
		coefficient |= swap >> swapSize
		dst[i] = decode(coefficient)
		swap <<= k
		i++

		if i < n && swapSize >= itemSize {
			dst[i] = decode(swap >> (64 - itemSize))
			swap <<= itemSize
			swapSize -= itemSize
			i++
		}
	}
}
